unit weewoo;

interface

uses
  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,
  System.Generics.Collections, System.Math.Vectors, System.Math,
  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects,
  FMX.Utils, Winapi.Windows;

type
  TWeetWoot = class(TForm)
    GameTimer: TTimer;
    procedure FormCreate(Sender: TObject);
    procedure FormKeyDown(Sender: TObject; var Key: Word; var KeyChar: Char; Shift: TShiftState);
    procedure FormKeyUp(Sender: TObject; var Key: Word; var KeyChar: Char; Shift: TShiftState);
    procedure GameTimerTimer(Sender: TObject);

    type
      TPlayer = record
        Rect: TRectangle;
        Velocity: TVector;
        IsOnGround: Boolean;
        CanWallJump: Boolean;
        WallJumpSide: TAlignLayout;
      end;

      TBlock = class
        Rect: TRectangle;
        VelocityY: Single;
        IsGroundBlock: Boolean;
      end;

  private
    FPlayer: TPlayer;
    FBlocks: TObjectList<TBlock>;
    FKeys: TDictionary<Word, Boolean>;
    FGameTime: Single;

    const
      Gravity = 0.2;
      PlayerSpeed = 4.0;
      JumpForce = -12.0;
      WallJumpHorizontalForce = 6.0;
      PanSpeed = 0.0; // simulating camera moving up
      BlockInitialFallSpeed = 0.5; // Initial speed for newly spawned blocks

    function IsKeyDown(Key: Word): Boolean;
    procedure UpdatePlayer;
    procedure UpdateBlocks;
    procedure UpdateWorld;
    procedure GameOver(AMessage: string);

  end;

var
  WeetWoot: TWeetWoot;

implementation

{$R *.fmx}

procedure TWeetWoot.FormCreate(Sender: TObject);
var
  GroundBlock: TBlock;
begin
  // Initialize keyboard state dictionary
  FKeys := TDictionary<Word, Boolean>.Create;

  // Initialize block list
  FBlocks := TObjectList<TBlock>.Create;

  // Create Player
  FPlayer.Rect := TRectangle.Create(Self);
  FPlayer.Rect.Parent := Self;
  FPlayer.Rect.Fill.Color := TAlphaColors.Black;
  FPlayer.Rect.Width := 20;
  FPlayer.Rect.Height := 20;
  FPlayer.Rect.Position.X := (Self.Width - FPlayer.Rect.Width) / 2;
  FPlayer.Rect.Position.Y := Self.Height - FPlayer.Rect.Height - 50;
  FPlayer.Velocity := TVector.Create(0, 0);
  FPlayer.IsOnGround := False; // Player starts airborne, will fall onto ground block
  FPlayer.CanWallJump := False;
  FGameTime := 0;

  // --- Create Initial Ground Block ---
  GroundBlock := TBlock.Create;
  GroundBlock.Rect := TRectangle.Create(Self);
  GroundBlock.Rect.Parent := Self;
  GroundBlock.Rect.Fill.Color := TAlphaColors.Sienna; // A different color for ground
  GroundBlock.Rect.Width := Self.Width; // Full width of the screen
  GroundBlock.Rect.Height := 50; // Thicker ground
  GroundBlock.Rect.Position.X := 0;
  GroundBlock.Rect.Position.Y := Self.Height - GroundBlock.Rect.Height;
  GroundBlock.VelocityY := 0; // The ground block does not fall
  GroundBlock.IsGroundBlock := True;
  FBlocks.Add(GroundBlock);
  // --- End Initial Ground Block ---

  GameTimer.OnTimer := GameTimerTimer;
  GameTimer.Interval := 16; // A good interval for ~60 FPS (1000ms / 60 frames = ~16.67ms)
  GameTimer.Enabled := True;
end;

procedure TWeetWoot.FormKeyDown(Sender: TObject; var Key: Word;
  var KeyChar: Char; Shift: TShiftState);
begin
  FKeys.AddOrSetValue(Key, True);
  OutputDebugString(PChar('Key Down: ' + IntToStr(Key) + #13#10)); // Debugging key presses
end;

procedure TWeetWoot.FormKeyUp(Sender: TObject; var Key: Word; var KeyChar: Char;
  Shift: TShiftState);
begin
  FKeys.AddOrSetValue(Key, False);
  OutputDebugString(PChar('Key Up: ' + IntToStr(Key) + #13#10)); // Debugging key releases
end;

// Helper function to check key state
function TWeetWoot.IsKeyDown(Key: Word): Boolean;
begin
  Result := FKeys.TryGetValue(Key, Result) and Result;
  //Result := FKeys.ContainsKey(Key) and FKeys.Items[Key];
end;

procedure TWeetWoot.GameTimerTimer(Sender: TObject);
begin
  // OutputDebugString('GameTimerTimer fired!'#13#10); // Can be removed if too noisy
  UpdatePlayer;
  UpdateBlocks;
  UpdateWorld;
  // OutputDebugString('GameTimerTimer ran all 3 main funcs!'#13#10); // Can be removed if too noisy
end;

procedure TWeetWoot.UpdatePlayer;
var
  NextPos: TRectF;
  CollidedBlock: TBlock;
  CollidedWithWall: Boolean;
  tempPlayerY: Single; // Store player's Y position before X collision check
begin
  // --- Horizontal Movement ---
  if IsKeyDown(Ord(37)) then // Left
    FPlayer.Velocity.X := -PlayerSpeed
  else if IsKeyDown(Ord(39)) then // Right
    FPlayer.Velocity.X := PlayerSpeed
  else
    FPlayer.Velocity.X := 0;

  // --- Apply Gravity (always applies, even if on ground, to detect falling off edge) ---
  FPlayer.Velocity.Y := FPlayer.Velocity.Y + Gravity;

  // --- Jumping ---
  // A note on 'W' key for jumping:
  // Using IsKeyDown(Ord('W')) means holding 'W' down will result in continuous jumps/flying.
  // For single jump per press, you'd need to track if 'W' was *just pressed* this frame.
  // For now, keeping current behavior.
  if IsKeyDown(38) then
  begin
    if FPlayer.IsOnGround then // Normal Jump
    begin
      FPlayer.Velocity.Y := JumpForce;
      FPlayer.IsOnGround := False; // No longer on ground after jumping
    end
    else if FPlayer.CanWallJump then // Wall Jump
    begin
      FPlayer.Velocity.Y := JumpForce; // Jump up
      if FPlayer.WallJumpSide = TAlignLayout.Left then
        FPlayer.Velocity.X := WallJumpHorizontalForce // Push right
      else
        FPlayer.Velocity.X := -WallJumpHorizontalForce; // Push left
      FPlayer.CanWallJump := False; // Can only wall jump once per touch
    end;
  end;

  // --- Power Drop ---
  if IsKeyDown(Ord(40)) and not FPlayer.IsOnGround then
  begin
    FPlayer.Velocity.Y := FPlayer.Velocity.Y + Gravity * 2; // Extra gravity
  end;

  // Limit player fall speed (optional, but good for control)
  if FPlayer.Velocity.Y > 15 then FPlayer.Velocity.Y := 15;

   // Reset collision states for this frame
  FPlayer.IsOnGround := False;
  FPlayer.CanWallJump := False;
  CollidedWithWall := False;

  // Store player's current bounds for collision calculations
  var PlayerCurrentBounds := FPlayer.Rect.BoundsRect;

  // --- Resolve Y-axis Collision ---
  // (Your existing Y-axis collision code, no changes needed here for this issue)
  NextPos := PlayerCurrentBounds;
  NextPos.Offset(0, FPlayer.Velocity.Y);

  for CollidedBlock in FBlocks do
  begin
    if NextPos.IntersectsWith(CollidedBlock.Rect.BoundsRect) then
    begin
      if FPlayer.Velocity.Y > 0 then // Moving Down (landing)
      begin
        FPlayer.IsOnGround := True;
        FPlayer.Velocity.Y := 0;
        FPlayer.Rect.Position.Y := CollidedBlock.Rect.Position.Y - FPlayer.Rect.Height;
      end
      else if FPlayer.Velocity.Y < 0 then // Moving Up (hit ceiling)
      begin
        FPlayer.Velocity.Y := 0;
        FPlayer.Rect.Position.Y := CollidedBlock.Rect.Position.Y + CollidedBlock.Rect.Height;
      end;
      Break;
    end;
  end;

  if not FPlayer.IsOnGround or (FPlayer.Velocity.Y <> 0) then
      FPlayer.Rect.Position.Y := FPlayer.Rect.Position.Y + FPlayer.Velocity.Y;


  // --- Resolve X-axis Collision ---
  NextPos := FPlayer.Rect.BoundsRect; // Get player's current position (possibly Y-adjusted)
  NextPos.Offset(FPlayer.Velocity.X, 0); // Project player's X movement

  for CollidedBlock in FBlocks do // Iterate through ALL blocks
  begin
    // IMPORTANT FIX: Skip horizontal collision with the ground block if the player is on it
    // This allows the player to slide horizontally along the ground.
    if CollidedBlock.IsGroundBlock and FPlayer.IsOnGround then // Check if it's the ground block AND player is currently on ground
    begin
      Continue; // Skip this block for horizontal collision checks if it's the ground
    end;

    // Now, check for actual wall-like collisions with other blocks or non-ground parts
    if NextPos.IntersectsWith(CollidedBlock.Rect.BoundsRect) then
    begin
      CollidedWithWall := True;
      if FPlayer.Velocity.X > 0 then // Moving right
      begin
        FPlayer.Velocity.X := 0;
        FPlayer.Rect.Position.X := CollidedBlock.Rect.Position.X - FPlayer.Rect.Width;
        FPlayer.WallJumpSide := TAlignLayout.Left;
      end
      else if FPlayer.Velocity.X < 0 then // Moving left
      begin
        FPlayer.Velocity.X := 0;
        FPlayer.Rect.Position.X := CollidedBlock.Rect.Position.X + CollidedBlock.Rect.Width;
        FPlayer.WallJumpSide := TAlignLayout.Right;
      end;
      Break; // Found an X-collision, break to prevent multiple snaps
    end;
  end;

  // Apply resolved X position.
  if FPlayer.Velocity.X <> 0 then
    FPlayer.Rect.Position.X := FPlayer.Rect.Position.X + FPlayer.Velocity.X;


  // A wall-jump is possible if we are touching a wall and not on the ground
  // (FPlayer.CanWallJump is reset at start, then set here if true based on actual collision)
  if CollidedWithWall and not FPlayer.IsOnGround then
    FPlayer.CanWallJump := True;

  // --- Screen Boundaries (for player horizontal) ---
  if FPlayer.Rect.Position.X < 0 then FPlayer.Rect.Position.X := 0;
  if FPlayer.Rect.Position.X > Self.Width - FPlayer.Rect.Width then
    FPlayer.Rect.Position.X := Self.Width - FPlayer.Rect.Width;

  // --- Game Over Check ---
  // Player falls out of view if they go below the bottom edge of the form
  if FPlayer.Rect.Position.Y > Self.Height then
    GameOver('You fell out of view!');
end;


procedure TWeetWoot.UpdateBlocks;
var
  i: Integer;
  Block: TBlock;
  OtherBlock: TBlock;
  Crushed: Boolean;
  BlockNextPos: TRectF;
begin
  Crushed := False; // Assume not crushed at start of frame

  // --- Spawn New Blocks ---
  // Spawn a new block approximately every second (60 frames * 16ms/frame = ~1 second)
  if RandomRange(0, 60) = 0 then // This triggers approximately every 61 frames (0-60)
  begin
    var NewBlock := TBlock.Create;
    NewBlock.Rect := TRectangle.Create(Self);
    NewBlock.Rect.Parent := Self;
    NewBlock.Rect.Fill.Color := TAlphaColors.Darkgray;
    NewBlock.Rect.Width := RandomRange(60, 120); // Random width
    NewBlock.Rect.Height := 20;
    NewBlock.Rect.Position.X := RandomRange(0, Round(Self.Width - NewBlock.Rect.Width));
    NewBlock.Rect.Position.Y := -NewBlock.Rect.Height; // Start just off-screen at the top
    NewBlock.VelocityY := BlockInitialFallSpeed; // Give new blocks an initial falling velocity
    FBlocks.Add(NewBlock);
  end;

  // --- Update Existing Blocks and Handle Collisions ---
  for i := FBlocks.Count - 1 downto 0 do // Iterate backwards for safe deletion
  begin
    Block := FBlocks[i];

    // Blocks apply their own gravity (unless it's the static ground block)
    if Block.VelocityY <> 0 then // Only apply gravity if block is currently falling/moving
      Block.VelocityY := Block.VelocityY + Gravity;

    // Limit block falling speed (optional, but good for control)
    if Block.VelocityY > 10 then Block.VelocityY := 10; // Max fall speed for blocks

    // Calculate next potential position for the current block
    BlockNextPos := Block.Rect.BoundsRect;
    BlockNextPos.Offset(0, Block.VelocityY);

    // CRITICAL FIX 2 & 3: Check for collision with OTHER blocks (including the ground block)
    var BlockLanded: Boolean := False;
    for OtherBlock in FBlocks do
    begin
      // Don't check collision with itself, and only check if the other block is not the one falling through
      if (Block = OtherBlock) then
        Continue; // Skip self-collision

      // Check if the current block (moving) would intersect with any other static/landed block
      if BlockNextPos.IntersectsWith(OtherBlock.Rect.BoundsRect) then
      begin
        // If the block is moving down and would hit another block
        if Block.VelocityY > 0 then // Only consider downward movement for landing
        begin
          Block.VelocityY := 0; // Stop falling
          // Snap block to just on top of the OtherBlock
          Block.Rect.Position.Y := OtherBlock.Rect.Position.Y - Block.Rect.Height;
          BlockLanded := True;
        end;
        // If blocks could be moving up, you'd need that logic too for hitting ceilings.
        // For stacking blocks, a simple downward collision check is sufficient.
        Break; // Once it hits one block, it stops for this axis.
      end;
    end;

    // Apply block's vertical movement IF it hasn't landed on something
    if not BlockLanded then
      Block.Rect.Position.Y := Block.Rect.Position.Y + Block.VelocityY;


    // Check for collision with player (crush)
    // This logic is a simple check: if the player's rectangle overlaps the block's rectangle AND
    // the block's top is above the player's top AND the block is moving downwards.
    // A more precise crushing check would involve checking if the block *moved into* the player from above.
    if FPlayer.Rect.BoundsRect.IntersectsWith(Block.Rect.BoundsRect) then
    begin
      // If the block is falling and its top is above or nearly at the player's top, it might be crushing
      if (Block.VelocityY > 0) and (FPlayer.Rect.Position.Y >= Block.Rect.Position.Y + Block.Rect.Height - 5) then // + Block.Rect.Height - 5 to check bottom part
        Crushed := True;
    end;


    // Remove blocks that go off the bottom of the screen
    if Block.Rect.Position.Y > Self.Height then
    begin
      Block.Rect.Free;
      FBlocks.Delete(i);
    end;
  end;

  if Crushed then
    GameOver('Ouch.. you were crushed!');
end;

procedure TWeetWoot.UpdateWorld;
var
  Block: TBlock;
  lerpFactor: Single;
begin
  // --- Pan the View ---
  // Move the player and all blocks down to simulate the camera moving up
  FPlayer.Rect.Position.Y := FPlayer.Rect.Position.Y + PanSpeed;
  for Block in FBlocks do
  begin
    Block.Rect.Position.Y := Block.Rect.Position.Y + PanSpeed;
  end;

  // --- Update Background (commented out as per your previous code) ---
  // FGameTime := FGameTime + GameTimer.Interval / 1000.0;
  // lerpFactor := Min(FGameTime / 120.0, 1.0);
  Self.Fill.Color := TAlphaColorRec.Whitesmoke; // (TAlphaColors.White, TAlphaColors.Dimgray, lerpFactor);
end;

procedure TWeetWoot.GameOver(AMessage: string);
begin
  GameTimer.Enabled := False;
  ShowMessage(AMessage + #13#10 + 'Click OK to close.');
  Application.Terminate;
end;

end.
